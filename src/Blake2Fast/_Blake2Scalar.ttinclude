<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
//------------------------------------------------------------------------------
//	<auto-generated>
//		This code was generated from a template.
//		Manual changes to this file will be overwritten if the code is regenerated.
//	</auto-generated>
//------------------------------------------------------------------------------

using System.Runtime.CompilerServices;

namespace SauceControl.Blake2Fast
{
	unsafe internal partial struct Blake2<#= alg.suffix #>Context
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static <#= alg.wtype #> ror(<#= alg.wtype #> x, byte y) => (x >> y) ^ (x << (<#= alg.bits #> - y));

		unsafe private static void mixScalar(Blake2<#= alg.suffix #>Context* s, <#= alg.wtype #>* m)
		{
<#
mixvars (alg, new[] {12, 13, 14});
#>
			v12 ^= s->t[0];
			v13 ^= s->t[1];
			v14 ^= s->f[0];

<#
for (int i = 0; i < alg.rounds; i++) {
	int s = i % 10;
	if (i > 0) { WriteLine($"\t\t\t//ROUND {i+1}"); }
	if (i == 0) { mixvars(alg, new[] {0, 4, 8}); }
	mix(alg, 0, 4,  8, 12, sigma[s][ 0], sigma[s][ 1]);
	if (i == 0) { mixvars(alg, new[] {1, 5, 9}); }
	mix(alg, 1, 5,  9, 13, sigma[s][ 2], sigma[s][ 3]);
	if (i == 0) { mixvars(alg, new[] {2, 6, 10}); }
	mix(alg, 2, 6, 10, 14, sigma[s][ 4], sigma[s][ 5]);
	if (i == 0) { mixvars(alg, new[] {3, 7, 11, 15}); }
	mix(alg, 3, 7, 11, 15, sigma[s][ 6], sigma[s][ 7]);
	mix(alg, 0, 5, 10, 15, sigma[s][ 8], sigma[s][ 9]);
	mix(alg, 1, 6, 11, 12, sigma[s][10], sigma[s][11]);
	mix(alg, 2, 7,  8, 13, sigma[s][12], sigma[s][13]);
	mix(alg, 3, 4,  9, 14, sigma[s][14], sigma[s][15]);
}

for (int i = 0; i < 8; i++) {
#>
			s->h[<#=i#>] ^= v<#=i#> ^ v<#=i+8#>;
<#
}
#>
		}
	}
}
<#+

byte[][] sigma = new byte[][] {
	new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
	new byte[] { 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 },
	new byte[] { 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 },
	new byte[] { 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 },
	new byte[] { 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 },
	new byte[] { 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 },
	new byte[] { 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 },
	new byte[] { 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 },
	new byte[] { 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 },
	new byte[] { 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 }
};

void mixvars(b2alg alg, int[] pos)
{
	foreach (int j in pos) {
#>
			<#= alg.wtype #> v<#=j#> = <#= j < 8 ? $"s->h[{j}]" : string.Format(alg.ivfmt, alg.iv[j-8]) #>;
<#+
	}
	WriteLine(null);
}

void mix(b2alg alg, int a, int b, int c, int d, int x, int y)
{
	// code structured for optimal JIT output
#>
			v<#=a#> += v<#=b#> + m[<#=x#>];
			v<#=d#> ^= v<#=a#>;
			v<#=d#> = ror(v<#=d#>, <#= alg.bits / 2 #>);
			v<#=c#> += v<#=d#>;
			v<#=b#> ^= v<#=c#>;
			v<#=b#> = ror(v<#=b#>, <#= alg.bits / 8 * 3 #>);
			v<#=a#> += v<#=b#> + m[<#=y#>];
			v<#=d#> ^= v<#=a#>;
			v<#=d#> = ror(v<#=d#>, <#= alg.bits / 4 #>);
			v<#=c#> += v<#=d#>;
			v<#=b#> ^= v<#=c#>;
			v<#=b#> = ror(v<#=b#>, <#= alg.bits == 64 ? 63 : 7 #>);

<#+
}
#>